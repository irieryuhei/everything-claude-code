# Everything Claude Code 完全ガイド

![Header: The Longform Guide to Everything Claude Code](./assets/images/longform/01-header.png)

---

> **前提条件**: このガイドは[Everything Claude Code 簡易ガイド](./the-shortform-guide.md)を基にしています。スキル、フック、サブエージェント、MCP、プラグインをまだセットアップしていない場合は、先にそちらをお読みください。

![Reference to Shorthand Guide](./assets/images/longform/02-shortform-reference.png)
*簡易ガイド - 先にお読みください*

簡易ガイドでは、基礎的なセットアップ（スキルとコマンド、フック、サブエージェント、MCP、プラグイン、効果的なClaude Codeワークフローの基盤となる設定パターン）を説明しました。それはセットアップガイドであり、基本インフラストラクチャでした。

この完全ガイドでは、生産的なセッションと無駄なセッションを分ける技術について詳しく説明します。簡易ガイドをまだ読んでいない場合は、まず設定をセットアップしてください。以下は、スキル、エージェント、フック、MCPがすでに設定され、動作していることを前提としています。

ここでのテーマは、トークン経済学、メモリの永続化、検証パターン、並列化戦略、再利用可能なワークフローを構築することの複利効果です。これらは、最初の1時間でコンテキストの劣化に悩まされるか、何時間も生産的なセッションを維持できるかの違いを生む、10ヶ月以上の日常使用で洗練されたパターンです。

簡易ガイドと完全ガイドで説明されているすべてがGitHubで利用可能です：`github.com/affaan-m/everything-claude-code`

---

## ヒントとコツ

### 一部のMCPは置き換え可能でコンテキストウィンドウを節約できる

バージョン管理（GitHub）、データベース（Supabase）、デプロイ（Vercel、Railway）などのMCPについては、これらのプラットフォームのほとんどがすでにMCPが本質的にラップしているだけの堅牢なCLIを持っています。MCPは便利なラッパーですが、コストがかかります。

MCPを実際に使用せずに（それに伴うコンテキストウィンドウの減少なしに）CLIをMCPのように機能させるには、機能をスキルとコマンドにバンドルすることを検討してください。MCPが公開している便利なツールを取り出し、それらをコマンドに変換します。

例：GitHub MCPを常にロードする代わりに、好みのオプションで`gh pr create`をラップする`/gh-pr`コマンドを作成します。Supabase MCPがコンテキストを消費する代わりに、Supabase CLIを直接使用するスキルを作成します。

遅延ロードにより、コンテキストウィンドウの問題はほぼ解決されています。しかし、トークン使用量とコストは同じようには解決されていません。CLI + スキルアプローチは依然としてトークン最適化の方法です。

---

## 重要事項

### コンテキストとメモリ管理

セッション間でメモリを共有するには、進行状況を要約してチェックし、`.claude`フォルダ内の`.tmp`ファイルに保存し、セッション終了までそれに追記するスキルまたはコマンドが最適です。翌日には、それをコンテキストとして使用し、中断したところから再開できます。古いコンテキストが新しい作業を汚染しないよう、各セッションごとに新しいファイルを作成します。

![Session Storage File Tree](./assets/images/longform/03-session-storage.png)
*セッションストレージの例 -> https://github.com/affaan-m/everything-claude-code/tree/main/examples/sessions*

Claudeは現在の状態を要約するファイルを作成します。それをレビューし、必要に応じて編集を依頼してから、新しいセッションを開始します。新しい会話では、ファイルパスを提供するだけです。コンテキスト制限に達し、複雑な作業を続ける必要がある場合に特に有用です。これらのファイルには以下を含めるべきです：
- どのアプローチが（証拠とともに検証可能に）機能したか
- どのアプローチが試されたが機能しなかったか
- どのアプローチがまだ試されておらず、何が残っているか

**戦略的なコンテキストクリア：**

計画が設定され、コンテキストがクリアされたら（Claude Codeのプランモードのデフォルトオプション）、計画に基づいて作業できます。これは、実行にもはや関係のない多くの探索コンテキストが蓄積された場合に有用です。戦略的な圧縮には、自動圧縮を無効にします。論理的な間隔で手動で圧縮するか、それを行うスキルを作成します。

**上級：動的システムプロンプトインジェクション**

私が習得したパターンの1つ：毎回セッションでロードされるCLAUDE.md（ユーザースコープ）や`.claude/rules/`（プロジェクトスコープ）だけにすべてを置く代わりに、CLIフラグを使用してコンテキストを動的に注入します。

```bash
claude --system-prompt "$(cat memory.md)"
```

これにより、いつどのコンテキストをロードするかをより外科的に制御できます。システムプロンプトのコンテンツは、ユーザーメッセージよりも高い権限を持ち、ユーザーメッセージはツール結果よりも高い権限を持ちます。

**実践的なセットアップ：**

```bash
# 日常の開発
alias claude-dev='claude --system-prompt "$(cat ~/.claude/contexts/dev.md)"'

# PRレビューモード
alias claude-review='claude --system-prompt "$(cat ~/.claude/contexts/review.md)"'

# リサーチ/探索モード
alias claude-research='claude --system-prompt "$(cat ~/.claude/contexts/research.md)"'
```

**上級：メモリ永続化フック**

メモリに役立つ、ほとんどの人が知らないフックがあります：

- **PreCompactフック**: コンテキスト圧縮の前に、重要な状態をファイルに保存
- **Stopフック（セッション終了）**: セッション終了時に、学習をファイルに永続化
- **SessionStartフック**: 新しいセッションで、以前のコンテキストを自動的にロード

これらのフックを構築し、リポジトリ `github.com/affaan-m/everything-claude-code/tree/main/hooks/memory-persistence` にあります。

---

### 継続的学習 / メモリ

プロンプトを何度も繰り返し、Claudeが同じ問題に遭遇したり、以前聞いた応答を返したりした場合、それらのパターンはスキルに追加する必要があります。

**問題:** トークンの無駄、コンテキストの無駄、時間の無駄。

**解決策:** Claude Codeが些細でないことを発見したとき（デバッグ技術、回避策、プロジェクト固有のパターンなど）、その知識を新しいスキルとして保存します。次に同様の問題が発生したとき、スキルが自動的にロードされます。

これを行う継続的学習スキルを構築しました：`github.com/affaan-m/everything-claude-code/tree/main/skills/continuous-learning`

**なぜStopフック（UserPromptSubmitではなく）か：**

主要な設計上の決定は、UserPromptSubmitの代わりに**Stopフック**を使用することです。UserPromptSubmitはすべてのメッセージで実行され、すべてのプロンプトにレイテンシーを追加します。Stopはセッション終了時に1回だけ実行され、軽量で、セッション中の速度を低下させません。

---

### トークン最適化

**主要戦略：サブエージェントアーキテクチャ**

使用するツールとサブエージェントアーキテクチャを最適化し、タスクに十分な最も安価なモデルに委譲するように設計します。

**モデル選択クイックリファレンス：**

![Model Selection Table](./assets/images/longform/04-model-selection.png)
*様々な一般的なタスクに対するサブエージェントの仮想セットアップと選択の理由*

| タスクタイプ | モデル | 理由 |
| --- | --- | --- |
| 探索/検索 | Haiku | 高速、安価、ファイル検索には十分 |
| 単純な編集 | Haiku | 単一ファイルの変更、明確な指示 |
| マルチファイル実装 | Sonnet | コーディングに最適なバランス |
| 複雑なアーキテクチャ | Opus | 深い推論が必要 |
| PRレビュー | Sonnet | コンテキストを理解し、ニュアンスを捉える |
| セキュリティ分析 | Opus | 脆弱性を見逃す余裕がない |
| ドキュメント作成 | Haiku | 構造がシンプル |
| 複雑なバグのデバッグ | Opus | システム全体を頭に入れる必要がある |

コーディングタスクの90%はSonnetをデフォルトにします。最初の試行が失敗した場合、タスクが5ファイル以上にまたがる場合、アーキテクチャ上の決定、またはセキュリティクリティカルなコードの場合はOpusにアップグレードします。

**料金リファレンス：**

![Claude Model Pricing](./assets/images/longform/05-pricing-table.png)
*ソース: https://platform.claude.com/docs/en/about-claude/pricing*

**ツール固有の最適化：**

grepをmgrepに置き換え - 従来のgrepやripgrepと比較して平均約50%のトークン削減：

![mgrep Benchmark](./assets/images/longform/06-mgrep-benchmark.png)
*50タスクのベンチマークで、mgrep + Claude Codeは同等以上の品質で、grepベースのワークフローより約2倍少ないトークンを使用しました。ソース: https://github.com/mixedbread-ai/mgrep*

**モジュラーコードベースの利点：**

メインファイルが数千行ではなく数百行のより modullar なコードベースを持つことは、トークン最適化コストと最初の試行でタスクを正しく完了することの両方に役立ちます。

---

### 検証ループと評価

**ベンチマーキングワークフロー：**

スキルありとなしで同じことを要求し、出力の差を確認して比較：

会話をフォークし、スキルなしで一方に新しいワークツリーを作成し、最後にdiffを確認し、何がログされたかを見ます。

**評価パターンタイプ：**

- **チェックポイントベース評価**: 明示的なチェックポイントを設定し、定義された基準に対して検証し、進む前に修正
- **継続的評価**: N分ごとまたは大きな変更後に実行、フルテストスイート + lint

**主要メトリクス：**

```
pass@k: k回の試行のうち少なくとも1回が成功
        k=1: 70%  k=3: 91%  k=5: 97%

pass^k: k回の試行すべてが成功する必要がある
        k=1: 70%  k=3: 34%  k=5: 17%
```

動作するだけでよい場合は**pass@k**を使用。一貫性が重要な場合は**pass^k**を使用。

---

## 並列化

マルチClaudeターミナルセットアップで会話をフォークする場合、フォークと元の会話のアクションのスコープが明確に定義されていることを確認します。コード変更に関しては重複を最小限に抑えることを目指します。

**私の好みのパターン：**

コード変更にはメインチャット、コードベースとその現在の状態に関する質問や外部サービスのリサーチにはフォーク。

**任意のターミナル数について：**

![Boris on Parallel Terminals](./assets/images/longform/07-boris-parallel.png)
*Boris（Anthropic）による複数のClaudeインスタンスの実行について*

Borisには並列化に関するヒントがあります。彼はローカルで5つ、アップストリームで5つのClaudeインスタンスを実行するようなことを提案しています。任意のターミナル数を設定することはお勧めしません。ターミナルの追加は真の必要性から行うべきです。

あなたの目標は：**最小限の並列化で、どれだけ多くのことができるか。**

**並列インスタンス用のGitワークツリー：**

```bash
# 並列作業用のワークツリーを作成
git worktree add ../project-feature-a feature-a
git worktree add ../project-feature-b feature-b
git worktree add ../project-refactor refactor-branch

# 各ワークツリーは独自のClaudeインスタンスを取得
cd ../project-feature-a && claude
```

インスタンスのスケーリングを開始し、互いに重複するコードで複数のClaudeインスタンスが動作している場合は、gitワークツリーを使用し、各インスタンスの計画を明確に定義することが不可欠です。`/rename <名前>`を使用してすべてのチャットに名前を付けます。

![Two Terminal Setup](./assets/images/longform/08-two-terminals.png)
*開始セットアップ：左ターミナルはコーディング用、右ターミナルは質問用 - /renameと/forkを使用*

**カスケードメソッド：**

複数のClaude Codeインスタンスを実行する場合、「カスケード」パターンで整理：

- 新しいタスクは右の新しいタブで開く
- 左から右へ、古いものから新しいものへスイープ
- 一度に最大3-4タスクに集中

---

## 基礎作業

**2インスタンスキックオフパターン：**

自分のワークフロー管理では、2つのClaudeインスタンスを開いた状態で空のリポジトリを開始するのが好きです。

**インスタンス1：スキャフォールディングエージェント**
- 骨格と基礎を配置
- プロジェクト構造を作成
- 設定をセットアップ（CLAUDE.md、ルール、エージェント）

**インスタンス2：ディープリサーチエージェント**
- すべてのサービス、Web検索に接続
- 詳細なPRDを作成
- アーキテクチャのmermaid図を作成
- 実際のドキュメントクリップを含むリファレンスをコンパイル

**llms.txtパターン：**

利用可能な場合、多くのドキュメントリファレンスでドキュメントページに到達した後、`/llms.txt`を実行することで`llms.txt`を見つけることができます。これにより、LLMに最適化されたドキュメントのクリーンなバージョンが得られます。

**哲学：再利用可能なパターンを構築**

@omarsar0より：「初期の頃、再利用可能なワークフロー/パターンの構築に時間を費やしました。構築するのは面倒でしたが、モデルとエージェントハーネスが改善されるにつれて、驚くべき複利効果がありました。」

**投資すべきもの：**

- サブエージェント
- スキル
- コマンド
- プランニングパターン
- MCPツール
- コンテキストエンジニアリングパターン

---

## エージェントとサブエージェントのベストプラクティス

**サブエージェントコンテキスト問題：**

サブエージェントは、すべてをダンプする代わりに要約を返すことでコンテキストを節約するために存在します。しかし、オーケストレーターにはサブエージェントが持っていないセマンティックコンテキストがあります。サブエージェントはリテラルクエリのみを知っており、リクエストの背後にある目的は知りません。

**反復的取得パターン：**

1. オーケストレーターはすべてのサブエージェントの戻り値を評価
2. 受け入れる前にフォローアップの質問をする
3. サブエージェントがソースに戻り、回答を取得し、返す
4. 十分になるまでループ（最大3サイクル）

**キー：** クエリだけでなく、目的のコンテキストを渡す。

**シーケンシャルフェーズを持つオーケストレーター：**

```markdown
フェーズ1：リサーチ（Exploreエージェントを使用）→ research-summary.md
フェーズ2：計画（plannerエージェントを使用）→ plan.md
フェーズ3：実装（tdd-guideエージェントを使用）→ コード変更
フェーズ4：レビュー（code-reviewerエージェントを使用）→ review-comments.md
フェーズ5：検証（必要に応じてbuild-error-resolverを使用）→ 完了またはループバック
```

**主要ルール：**

1. 各エージェントは1つの明確な入力を取得し、1つの明確な出力を生成
2. 出力は次のフェーズの入力になる
3. フェーズをスキップしない
4. エージェント間で`/clear`を使用
5. 中間出力をファイルに保存

---

## 楽しいこと / 重要ではないが楽しいヒント

### カスタムステータスライン

`/statusline`を使用して設定できます - Claudeはあなたがまだ持っていないが設定でき、何を入れたいか聞いてくれると言います。

参照：https://github.com/sirmalloc/ccstatusline

### 音声文字起こし

音声でClaude Codeと話します。多くの人にとってタイピングより速いです。

- MacではsuperwhisperまたはMacWhisper
- 文字起こしのミスがあっても、Claudeは意図を理解します

### ターミナルエイリアス

```bash
alias c='claude'
alias gb='github'
alias co='code'
alias q='cd ~/Desktop/projects'
```

---

## マイルストーン

![25k+ GitHub Stars](./assets/images/longform/09-25k-stars.png)
*1週間以内で25,000以上のGitHubスター*

---

## リソース

**エージェントオーケストレーション：**

- https://github.com/ruvnet/claude-flow - 54以上の専門エージェントを持つエンタープライズオーケストレーションプラットフォーム

**自己改善メモリ：**

- https://github.com/affaan-m/everything-claude-code/tree/main/skills/continuous-learning
- rlancemartin.github.io/2025/12/01/claude_diary/ - セッション振り返りパターン

**システムプロンプトリファレンス：**

- https://github.com/x1xhlol/system-prompts-and-models-of-ai-tools - システムプロンプトのコレクション（110kスター）

**公式：**

- Anthropic Academy: anthropic.skilljar.com

---

## 参考文献

- [Anthropic: AIエージェントの評価を解明](https://www.anthropic.com/engineering/demystifying-evals-for-ai-agents)
- [YK: 32のClaude Codeヒント](https://agenticcoding.substack.com/p/32-claude-code-tips-from-basics-to)
- [RLanceMartin: セッション振り返りパターン](https://rlancemartin.github.io/2025/12/01/claude_diary/)
- @PerceptualPeak: サブエージェントコンテキストネゴシエーション
- @menhguin: エージェント抽象化ティアリスト
- @omarsar0: 複利効果の哲学

---

*両ガイドで説明されているすべてがGitHubの[everything-claude-code](https://github.com/affaan-m/everything-claude-code)で利用可能です*
